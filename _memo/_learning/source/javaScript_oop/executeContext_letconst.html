<!DOCTYPE html>
<html>
<head>
<meta charset="EUC-KR">
<title>Insert title here</title>
<script>
	//console.log(v0, l0); //선언 전에 접근 할 수 없다.
	var v0 = 'v0';
	let l0 = 'l0';
	console.log(v0, l0);
	//var로 선언시 global에 지정됨 -->global은 변수들이 워낙 많아서 실수로 v0를 건드릴수 있고 필요한 값을 찾을 때 찾기 힘듬 --> let, const 도입 --> script scope에 두어서
	//변수 찾기도 쉽고, global 변수와 충돌 방지
	
	// var v0 = 'v00';
	// let l0 = 'l00';
	
	function fn1(){
	    v0 = 'fn1-v0'; //global scope --> var로 선언
	    l0 = 'fn1-l0'; //script scope --> let으로 선언
	    console.log(v0, l0);
	}
	fn1();
	console.log(v0, l0); //v0: global, l0: script
	
	function fn2(){
	    var v0 = 'fn2-v0'; // local scope
	    let l0 = 'fn2-l0'; // local scope
	    console.log(v0, l0);
	}
	fn2();
	console.log(v0, l0); // v0: global scope, l0: script scope
	
	//var의 경우 함수안에서 사용되었을때 local scope를 가짐
	//let은 함수안에서 사용되었을때 local scope를 가질뿐만 아니라 블록에서도 block이라는 scope를 가지게됨 
	{
	    var v0 = 'block-v0'; //블록 밖에서 선언한것과 같은 global scope //☆ var은 함수안에 있을때 local이 되나 블록안에서는 여전히 global이다.
	    let l0 = 'block-l0'; //block scope //let은 함수안에 있을때 local scope이 되나 블록안에서는 block scope이 된다.
	    console.log(v0, l0);
	}
	console.log(v0, l0); //v0은 global, l0은 script
	
	var i = 'I';
	for(var i=0; i<1; i++){ // var이기에 i는 global scope
	    console.log(i);
	}
	console.log(i); // i = 1이 나옴==> 반복문에서 사용했던 값이 나온다. (i를 재할당)
	
	let j = 'J';
	for(let j=0; j<1; j++){ //let이기에 j는 script scope
	    console.log(j); //block 안의 값이 셋팅된것
	} // for문 빠져나오면 block이라는 scope이 사라짐
	console.log(j);// j = J가 됨
</script>
</script>
</head>
<body>

</body>
</html>